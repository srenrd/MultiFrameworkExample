using System;
using System.Text;

public static class Encryption
{
	public static string XorDecrypt(string cipherText)
	{
		return XorDecrypt(
			cipherText,
			Settings.Encryption.DefaultXorKeys,
			Settings.Encryption.UseBase64
		);
	}

	public static string XorDecrypt(string cipherText, int[] keys, bool inBase64)
	{
		byte[] cipherTextBytes = inBase64 ? Convert.FromBase64String(cipherText) : HexToBytes(cipherText);
		byte[] plainTextBytes  = new byte[cipherTextBytes.Length - 16];
		byte[] bytes           = new byte[16];

		bytes[0]  = (byte)(cipherTextBytes[0] ^ keys[0]);
		bytes[1]  = (byte)(cipherTextBytes[1] ^ keys[1]);
		bytes[2]  = (byte)(cipherTextBytes[2] ^ keys[2]);
		bytes[3]  = (byte)(cipherTextBytes[3] ^ keys[3]);
		bytes[4]  = (byte)(cipherTextBytes[4] ^ keys[4]);
		bytes[5]  = (byte)(cipherTextBytes[5] ^ keys[5]);
		bytes[6]  = (byte)(cipherTextBytes[6] ^ keys[6]);
		bytes[7]  = (byte)(cipherTextBytes[7] ^ keys[7]);
		bytes[8]  = (byte)(cipherTextBytes[cipherTextBytes.Length - 8] ^ keys[8]);
		bytes[9]  = (byte)(cipherTextBytes[cipherTextBytes.Length - 7] ^ keys[9]);
		bytes[10] = (byte)(cipherTextBytes[cipherTextBytes.Length - 6] ^ keys[10]);
		bytes[11] = (byte)(cipherTextBytes[cipherTextBytes.Length - 5] ^ keys[11]);
		bytes[12] = (byte)(cipherTextBytes[cipherTextBytes.Length - 4] ^ keys[12]);
		bytes[13] = (byte)(cipherTextBytes[cipherTextBytes.Length - 3] ^ keys[13]);
		bytes[14] = (byte)(cipherTextBytes[cipherTextBytes.Length - 2] ^ keys[14]);
		bytes[15] = (byte)(cipherTextBytes[cipherTextBytes.Length - 1] ^ keys[15]);

		int j = 0;

		for (int i = 8; i < cipherTextBytes.Length - 8; i++)
		{
			if (j >= 16)
				j = 0;

			plainTextBytes[i - 8] = (byte)((cipherTextBytes[i] ^ 135) ^ bytes[j]);
			j++;
		}

		return Encoding.UTF8.GetString(plainTextBytes);
	}

	public static string XorEncrypt(string plainText)
	{
		return XorEncrypt(
			plainText,
			Settings.Encryption.DefaultXorKeys,
			Settings.Encryption.UseBase64
		);
	}

	public static string XorEncrypt(string plainText, int[] keys, bool outBase64)
	{
		byte[] plainTextBytes  = Encoding.UTF8.GetBytes(plainText);
		byte[] cipherTextBytes = new byte[plainTextBytes.Length + 16];
		byte[] bytes           = Guid.NewGuid().ToByteArray();

		cipherTextBytes[0]                          = (byte)(bytes[0] ^ keys[0]);
		cipherTextBytes[1]                          = (byte)(bytes[1] ^ keys[1]);
		cipherTextBytes[2]                          = (byte)(bytes[2] ^ keys[2]);
		cipherTextBytes[3]                          = (byte)(bytes[3] ^ keys[3]);
		cipherTextBytes[4]                          = (byte)(bytes[4] ^ keys[4]);
		cipherTextBytes[5]                          = (byte)(bytes[5] ^ keys[5]);
		cipherTextBytes[6]                          = (byte)(bytes[6] ^ keys[6]);
		cipherTextBytes[7]                          = (byte)(bytes[7] ^ keys[7]);
		cipherTextBytes[cipherTextBytes.Length - 8] = (byte)(bytes[8] ^ keys[8]);
		cipherTextBytes[cipherTextBytes.Length - 7] = (byte)(bytes[9] ^ keys[9]);
		cipherTextBytes[cipherTextBytes.Length - 6] = (byte)(bytes[10] ^ keys[10]);
		cipherTextBytes[cipherTextBytes.Length - 5] = (byte)(bytes[11] ^ keys[11]);
		cipherTextBytes[cipherTextBytes.Length - 4] = (byte)(bytes[12] ^ keys[12]);
		cipherTextBytes[cipherTextBytes.Length - 3] = (byte)(bytes[13] ^ keys[13]);
		cipherTextBytes[cipherTextBytes.Length - 2] = (byte)(bytes[14] ^ keys[14]);
		cipherTextBytes[cipherTextBytes.Length - 1] = (byte)(bytes[15] ^ keys[15]);

		int j = 0;

		for (int i = 0; i < plainTextBytes.Length; i++)
		{
			if (j >= 16)
				j = 0;

			cipherTextBytes[8 + i] = (byte)((plainTextBytes[i] ^ bytes[j]) ^ 135);
			j++;
		}

		return outBase64 ? Convert.ToBase64String(cipherTextBytes) : BytesToHex(cipherTextBytes);
	}

    private static string BytesToHex(byte[] bytes)
    {
        char[] c = new char[bytes.Length * 2];
        byte b;

        for (int i = 0; i < bytes.Length; i++)
        {
            b = (byte)(bytes[i] >> 4);
            c[i * 2] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
            b = (byte)(bytes[i] & 0xF);
            c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
        }

        return new string(c);
    }

    private static byte[] HexToBytes(string hex)
    {
        byte[] bytes = new byte[hex.Length / 2];
        char c;

        for (int i = 0; i < bytes.Length; i++)
        {
            c = hex[i * 2];
            bytes[i] = (byte)((c > '9' ? (c > 'Z' ? (c - 'a' + 10) : (c - 'A' + 10)) : (c - '0')) << 4);
            c = hex[i * 2 + 1];
            bytes[i] |= (byte)(c > '9' ? (c > 'Z' ? (c - 'a' + 10) : (c - 'A' + 10)) : (c - '0'));
        }

        return bytes;
    }
}